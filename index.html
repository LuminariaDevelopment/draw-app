<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Fullscreen on iOS when added to Home Screen -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-title" content="Whiteboard" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <!-- Avoid phone number auto-linking & keep status bars white -->
  <meta name="format-detection" content="telephone=no" />
  <meta name="theme-color" content="#ffffff" />
  <!-- Fill the whole screen, respect iOS safe areas, prevent zoom -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Ultra-Minimal Whiteboard</title>
  <style>
    :root { --pen-color: #000000; }
    * { -webkit-tap-highlight-color: transparent; }
    html, body {
      margin: 0;
      padding: 0;
      background: #ffffff;
      height: 100%;
      overflow: hidden;
      -webkit-user-select: none; user-select: none;
      -webkit-touch-callout: none;
    }
    canvas {
      display: block;
      width: 100dvw;   /* dynamic viewport stops address-bar jump */
      height: 100dvh;
      touch-action: none;  /* disable scrolling/pinch so drawing works */
      cursor: crosshair;
      -webkit-user-select: none; user-select: none;
      -webkit-touch-callout: none;
    }

    /* Tiny, minimal toolbar */
    #toolbar {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 8px);
      left: calc(env(safe-area-inset-left, 0px) + 8px);
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 10;
      background: rgba(255,255,255,0.6);
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
      padding: 4px 6px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.08);
      -webkit-user-select: none; user-select: none;
    }

    /* Pen/Eraser toggle — square solid for pen, open square for eraser */
    #tool-toggle {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.2);
      background: var(--pen-color); /* solid square when pen */
      cursor: pointer;
      padding: 0;
      display: inline-block;
      outline: none;
      appearance: none;
    }
    #tool-toggle.eraser {
      background: transparent;       /* open square when eraser */
      border: 2px solid rgba(0,0,0,0.6);
    }

    /* Very small color dots */
    .swatch {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.2);
      cursor: pointer;
      padding: 0;
      outline: none;
      appearance: none;
    }
    .swatch[data-active="true"] {
      box-shadow: 0 0 0 2px rgba(0,0,0,0.25);
    }

    @media (display-mode: standalone) {
      #toolbar { top: calc(env(safe-area-inset-top, 0px) + 8px); }
    }
  </style>
</head>
<body>
  <!-- ultra-minimal toolbar -->
  <div id="toolbar" aria-label="Mini toolbar">
    <button id="tool-toggle" title="Toggle Eraser (E)" aria-pressed="false" aria-label="Toggle eraser"></button>
    <button class="swatch" id="sw-black"  title="Black (1)"  aria-label="Black"></button>
    <button class="swatch" id="sw-red"    title="Red (2)"    aria-label="Red"></button>
    <button class="swatch" id="sw-green"  title="Green (3)"  aria-label="Green"></button>
    <button class="swatch" id="sw-blue"   title="Blue (4)"   aria-label="Blue"></button>
  </div>

  <canvas id="board"></canvas>

  <script>
    (function () {
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d', { alpha: false });

      // Toolbar elements
      const btnToggle = document.getElementById('tool-toggle');
      const swatches = {
        black: document.getElementById('sw-black'),
        red:   document.getElementById('sw-red'),
        green: document.getElementById('sw-green'),
        blue:  document.getElementById('sw-blue')
      };

      // Color palette: 1–4
      const COLORS = {
        '1': '#000000',
        '2': '#e74c3c',
        '3': '#27ae60',
        '4': '#3498db'
      };
      const COLOR_KEYS = ['1','2','3','4'];

      // Apply color to swatches
      swatches.black.style.background = COLORS['1'];
      swatches.red.style.background   = COLORS['2'];
      swatches.green.style.background = COLORS['3'];
      swatches.blue.style.background  = COLORS['4'];

      // Drawing state
      let drawing = false;
      let strokes = [];     // finished strokes
      let redoStack = [];   // redo history
      let currentStroke = null;

      let currentColor = COLORS['1']; // default black
      let isEraser = false;           // toggled by button / 'E'
      const baseLineWidth = 3;        // pen width (CSS px)
      const eraserWidth   = 16;       // eraser width (CSS px)

      // Track CSS size for clear/repaint
      let cssW = 0, cssH = 0;

      // Only allow ONE active pointer (prevents two fingers drawing two lines)
      let activePointerId = null;

      // --- UI helpers ---
      function setActiveSwatchByColor(hex) {
        for (const el of Object.values(swatches)) el.dataset.active = 'false';
        if      (hex === COLORS['1']) swatches.black.dataset.active = 'true';
        else if (hex === COLORS['2']) swatches.red.dataset.active   = 'true';
        else if (hex === COLORS['3']) swatches.green.dataset.active = 'true';
        else if (hex === COLORS['4']) swatches.blue.dataset.active  = 'true';
      }
      function updatePenColorVar() {
        document.documentElement.style.setProperty('--pen-color', currentColor);
      }
      function setToggleUI() {
        // solid square when pen; open square when eraser
        btnToggle.classList.toggle('eraser', isEraser);
        btnToggle.setAttribute('aria-pressed', String(isEraser));
        btnToggle.title = isEraser ? 'Pen (E)' : 'Eraser (E)';
      }
      function toggleEraser() {
        isEraser = !isEraser;
        setToggleUI();
      }

      // Use visualViewport for iOS Safari accurate height
      function getViewportSize() {
        const vv = window.visualViewport;
        return {
          width: Math.round((vv ? vv.width : window.innerWidth)),
          height: Math.round((vv ? vv.height : window.innerHeight))
        };
      }
      function resizeToViewport() {
        const dpr = window.devicePixelRatio || 1;
        const { width, height } = getViewportSize();

        cssW = Math.max(1, width);
        cssH = Math.max(1, height);

        // CSS size
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';

        // Backing store size
        canvas.width = Math.max(1, Math.floor(cssW * dpr));
        canvas.height = Math.max(1, Math.floor(cssH * dpr));

        // Configure drawing context in CSS pixel units
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        repaint();
      }

      // --- drawing helpers ---
      function clearToWhite() {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, cssW, cssH);
      }
      function drawStroke(stroke) {
        if (!stroke || stroke.points.length === 0) return;
        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = stroke.width;
        const pts = stroke.points;
        if (pts.length === 1) {
          ctx.fillStyle = stroke.color;
          ctx.beginPath();
          ctx.arc(pts[0].x, pts[0].y, stroke.width / 2, 0, Math.PI * 2);
          ctx.fill();
          return;
        }
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.stroke();
      }
      function repaint() {
        clearToWhite();
        for (const s of strokes) drawStroke(s);
        if (currentStroke) drawStroke(currentStroke);
      }
      function strokeColorForTool() {
        return isEraser ? '#ffffff' : currentColor;
      }
      function strokeWidthForTool() {
        return isEraser ? eraserWidth : baseLineWidth;
      }
      function startDraw(x, y) {
        drawing = true;
        currentStroke = {
          color: strokeColorForTool(),
          width: strokeWidthForTool(),
          points: [{ x, y }]
        };
      }
      function addPoint(x, y) {
        if (!drawing || !currentStroke) return;
        const pts = currentStroke.points;
        const last = pts[pts.length - 1];
        if (last && last.x === x && last.y === y) return;
        currentStroke.points.push({ x, y });

        // draw latest segment for responsiveness
        if (pts.length >= 2) {
          ctx.strokeStyle = currentStroke.color;
          ctx.lineWidth = currentStroke.width;
          ctx.beginPath();
          const n = pts.length;
          ctx.moveTo(pts[n - 2].x, pts[n - 2].y);
          ctx.lineTo(pts[n - 1].x, pts[n - 1].y);
          ctx.stroke();
        }
      }
      function endDraw() {
        if (!drawing) return;
        drawing = false;
        if (currentStroke && currentStroke.points.length > 0) {
          strokes.push(currentStroke);
          redoStack = []; // new stroke invalidates redo history
        }
        currentStroke = null;
      }
      function undo() {
        if (strokes.length === 0) return;
        redoStack.push(strokes.pop());
        repaint();
      }
      function redo() {
        if (redoStack.length === 0) return;
        strokes.push(redoStack.pop());
        repaint();
      }

      // --- pointer handling (single active pointer only) ---
      canvas.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        // If another finger/stylus is already drawing, ignore additional pointers
        if (activePointerId !== null && e.pointerId !== activePointerId) return;

        activePointerId = e.pointerId;
        canvas.setPointerCapture(e.pointerId);
        startDraw(e.clientX, e.clientY);
      });

      canvas.addEventListener('pointermove', (e) => {
        if (e.pointerId !== activePointerId) return;
        e.preventDefault();
        if (!drawing) return;
        addPoint(e.clientX, e.clientY);
      });

      function stopPointer(e) {
        if (e.pointerId !== activePointerId) return;
        e.preventDefault();
        endDraw();
        try { canvas.releasePointerCapture(e.pointerId); } catch {}
        activePointerId = null;
      }
      canvas.addEventListener('pointerup', stopPointer);
      canvas.addEventListener('pointercancel', stopPointer);
      canvas.addEventListener('pointerout', stopPointer);
      canvas.addEventListener('pointerleave', stopPointer);

      // --- toolbar interactions ---
      btnToggle.addEventListener('click', () => {
        toggleEraser();
      });

      function pick(hex) {
        currentColor = hex;
        updatePenColorVar();    // update solid square color when pen
        isEraser = false;
        setToggleUI();
        setActiveSwatchByColor(hex);
      }
      swatches.black.addEventListener('click', () => pick(COLORS['1']));
      swatches.red.addEventListener('click',   () => pick(COLORS['2']));
      swatches.green.addEventListener('click', () => pick(COLORS['3']));
      swatches.blue.addEventListener('click',  () => pick(COLORS['4']));

      // --- keyboard shortcuts ---
      window.addEventListener('keydown', (e) => {
        const key = e.key;

        // color keys 1..4
        if (!e.ctrlKey && !e.metaKey && COLOR_KEYS.includes(key)) {
          pick(COLORS[key]);
          return;
        }
        // eraser toggle
        if (!e.ctrlKey && !e.metaKey && (key === 'e' || key === 'E')) {
          toggleEraser();
          return;
        }
        // undo / redo
        const isMod = e.ctrlKey || e.metaKey;
        if (isMod && key.toLowerCase() === 'z' && !e.shiftKey) {
          e.preventDefault();
          undo();
        } else if (isMod && ((key.toLowerCase() === 'z' && e.shiftKey) || key.toLowerCase() === 'y')) {
          e.preventDefault();
          redo();
        }
      });

      // Prevent selection/callouts/menus (no auto-select/highlight)
      document.addEventListener('gesturestart', (e) => e.preventDefault(), { passive: false });
      document.addEventListener('selectstart', (e) => e.preventDefault());
      window.addEventListener('contextmenu', (e) => e.preventDefault());

      // Handle viewport changes (especially iOS address bar show/hide)
      const vv = window.visualViewport;
      if (vv) vv.addEventListener('resize', resizeToViewport);
      window.addEventListener('resize', resizeToViewport);

      // Init
      setActiveSwatchByColor(currentColor);
      updatePenColorVar();
      setToggleUI();
      resizeToViewport();

      if (window.navigator.standalone) {
        document.documentElement.classList.add('ios-standalone');
      }
    })();
  </script>
</body>
</html>
