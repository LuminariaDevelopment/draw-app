<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Fullscreen on iOS when added to Home Screen -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-title" content="Whiteboard" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <!-- Helpful for Android and modern browsers -->
  <meta name="theme-color" content="#ffffff" />
  <!-- Fill the whole screen including iPhone safe areas -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Ultra-Minimal Whiteboard</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #ffffff;
      height: 100%;
      overflow: hidden;
    }
    /* Canvas uses dynamic viewport height so it fills the screen
       both in Safari and as an iOS Home Screen app. */
    canvas {
      display: block;
      width: 100dvw;   /* dynamic viewport units prevent toolbar jump */
      height: 100dvh;
      touch-action: none; /* enables smooth pen/touch drawing */
      cursor: crosshair;
    }

    /* Tiny, minimal toolbar */
    #toolbar {
      position: fixed;
      /* Respect iPhone notches / status bar in standalone */
      top: calc(env(safe-area-inset-top, 0px) + 8px);
      left: calc(env(safe-area-inset-left, 0px) + 8px);
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 10;
      background: rgba(255,255,255,0.6);
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
      padding: 4px 6px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.08);
    }
    /* Tiny pen/eraser toggle */
    #tool-toggle {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      display: inline-grid;
      place-items: center;
      border: 1px solid rgba(0,0,0,0.15);
      background: #fff;
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
    }
    #tool-toggle.active { /* eraser on */
      background: #f2f2f2;
      box-shadow: inset 0 0 0 2px rgba(0,0,0,0.25);
    }
    /* Very small color dots */
    .swatch {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.2);
      cursor: pointer;
    }
    .swatch[data-active="true"] {
      box-shadow: 0 0 0 2px rgba(0,0,0,0.25);
    }

    /* If the app is launched as a standalone PWA (iOS/Android), you can target it: */
    @media (display-mode: standalone) {
      #toolbar { top: calc(env(safe-area-inset-top, 0px) + 8px); }
    }
  </style>
</head>
<body>
  <!-- ultra-minimal toolbar -->
  <div id="toolbar" aria-label="Mini toolbar">
    <button id="tool-toggle" title="Toggle Eraser (E)" aria-pressed="false">✎</button>
    <button class="swatch" id="sw-black"  title="Black (1)"></button>
    <button class="swatch" id="sw-red"    title="Red (2)"></button>
    <button class="swatch" id="sw-green"  title="Green (3)"></button>
    <button class="swatch" id="sw-blue"   title="Blue (4)"></button>
  </div>

  <canvas id="board"></canvas>

  <script>
    (function () {
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d', { alpha: false });

      // Toolbar elements
      const btnToggle = document.getElementById('tool-toggle');
      const swatches = {
        black: document.getElementById('sw-black'),
        red:   document.getElementById('sw-red'),
        green: document.getElementById('sw-green'),
        blue:  document.getElementById('sw-blue')
      };

      // Tiny palette: 1–4
      const COLORS = {
        '1': '#000000', // black
        '2': '#e74c3c', // red
        '3': '#27ae60', // green
        '4': '#3498db'  // blue
      };
      const COLOR_KEYS = ['1','2','3','4'];

      // Apply color to UI
      swatches.black.style.background = COLORS['1'];
      swatches.red.style.background   = COLORS['2'];
      swatches.green.style.background = COLORS['3'];
      swatches.blue.style.background  = COLORS['4'];

      // Drawing state
      let drawing = false;
      let strokes = [];     // finished strokes
      let redoStack = [];   // redo history
      let currentStroke = null;

      let currentColor = COLORS['1']; // default black
      let isEraser = false;           // toggled by button / 'E'
      const baseLineWidth = 3;        // pen width (CSS px)
      const eraserWidth   = 16;       // eraser width (CSS px)

      // Track CSS size for clear/repaint
      let cssW = 0, cssH = 0;

      function setActiveSwatchByColor(hex) {
        for (const el of Object.values(swatches)) el.dataset.active = 'false';
        if      (hex === COLORS['1']) swatches.black.dataset.active = 'true';
        else if (hex === COLORS['2']) swatches.red.dataset.active   = 'true';
        else if (hex === COLORS['3']) swatches.green.dataset.active = 'true';
        else if (hex === COLORS['4']) swatches.blue.dataset.active  = 'true';
      }

      function setToggleUI() {
        btnToggle.classList.toggle('active', isEraser);
        btnToggle.setAttribute('aria-pressed', String(isEraser));
        btnToggle.title = isEraser ? 'Pen (E)' : 'Eraser (E)';
        btnToggle.textContent = isEraser ? '⌫' : '✎';
      }

      function toggleEraser() {
        isEraser = !isEraser;
        setToggleUI();
      }

      // Use visualViewport when available for more accurate height on iOS Safari
      function getViewportSize() {
        const vv = window.visualViewport;
        return {
          width: Math.round((vv ? vv.width : window.innerWidth)),
          height: Math.round((vv ? vv.height : window.innerHeight))
        };
      }

      function resizeToViewport() {
        const dpr = window.devicePixelRatio || 1;
        const { width, height } = getViewportSize();

        cssW = Math.max(1, width);
        cssH = Math.max(1, height);

        // Ensure CSS size matches viewport
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';

        // Backing store size scaled by DPR
        canvas.width = Math.max(1, Math.floor(cssW * dpr));
        canvas.height = Math.max(1, Math.floor(cssH * dpr));

        // Configure drawing context in CSS pixel units
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        repaint();
      }

      function clearToWhite() {
        // ctx is scaled to CSS pixels, so fill with CSS units
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, cssW, cssH);
      }

      function drawStroke(stroke) {
        if (!stroke || stroke.points.length === 0) return;
        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = stroke.width;
        const pts = stroke.points;
        if (pts.length === 1) {
          ctx.fillStyle = stroke.color;
          ctx.beginPath();
          ctx.arc(pts[0].x, pts[0].y, stroke.width / 2, 0, Math.PI * 2);
          ctx.fill();
          return;
        }
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.stroke();
      }

      function repaint() {
        clearToWhite();
        for (const s of strokes) drawStroke(s);
        if (currentStroke) drawStroke(currentStroke);
      }

      function strokeColorForTool() {
        return isEraser ? '#ffffff' : currentColor;
      }
      function strokeWidthForTool() {
        return isEraser ? eraserWidth : baseLineWidth;
      }

      function startDraw(x, y) {
        drawing = true;
        currentStroke = {
          color: strokeColorForTool(),
          width: strokeWidthForTool(),
          points: [{ x, y }]
        };
      }

      function addPoint(x, y) {
        if (!drawing || !currentStroke) return;
        const pts = currentStroke.points;
        const last = pts[pts.length - 1];
        if (last && last.x === x && last.y === y) return;
        currentStroke.points.push({ x, y });

        // draw latest segment for responsiveness
        if (pts.length >= 2) {
          ctx.strokeStyle = currentStroke.color;
          ctx.lineWidth = currentStroke.width;
          ctx.beginPath();
          const n = pts.length;
          ctx.moveTo(pts[n - 2].x, pts[n - 2].y);
          ctx.lineTo(pts[n - 1].x, pts[n - 1].y);
          ctx.stroke();
        }
      }

      function endDraw() {
        if (!drawing) return;
        drawing = false;
        if (currentStroke && currentStroke.points.length > 0) {
          strokes.push(currentStroke);
          redoStack = []; // new stroke invalidates redo history
        }
        currentStroke = null;
      }

      function undo() {
        if (strokes.length === 0) return;
        redoStack.push(strokes.pop());
        repaint();
      }

      function redo() {
        if (redoStack.length === 0) return;
        strokes.push(redoStack.pop());
        repaint();
      }

      // Pointer events
      canvas.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        canvas.setPointerCapture(e.pointerId);
        startDraw(e.clientX, e.clientY);
      });
      canvas.addEventListener('pointermove', (e) => {
        if (!drawing) return;
        e.preventDefault();
        addPoint(e.clientX, e.clientY);
      });
      function stopPointer(e) {
        if (!drawing) return;
        e.preventDefault();
        endDraw();
        try { canvas.releasePointerCapture(e.pointerId); } catch {}
      }
      canvas.addEventListener('pointerup', stopPointer);
      canvas.addEventListener('pointercancel', stopPointer);
      canvas.addEventListener('pointerout', stopPointer);
      canvas.addEventListener('pointerleave', stopPointer);

      // Toolbar interactions
      btnToggle.addEventListener('click', toggleEraser);
      function pick(hex) {
        currentColor = hex;
        isEraser = false;
        setToggleUI();
        setActiveSwatchByColor(hex);
      }
      swatches.black.addEventListener('click', () => pick(COLORS['1']));
      swatches.red.addEventListener('click',   () => pick(COLORS['2']));
      swatches.green.addEventListener('click', () => pick(COLORS['3']));
      swatches.blue.addEventListener('click',  () => pick(COLORS['4']));

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        const key = e.key;

        // Colors 1..4
        if (!e.ctrlKey && !e.metaKey && COLOR_KEYS.includes(key)) {
          pick(COLORS[key]);
          return;
        }
        // Eraser toggle
        if (!e.ctrlKey && !e.metaKey && (key === 'e' || key === 'E')) {
          toggleEraser();
          return;
        }
        // Undo / Redo
        const isMod = e.ctrlKey || e.metaKey;
        if (isMod && key.toLowerCase() === 'z' && !e.shiftKey) {
          e.preventDefault();
          undo();
        } else if (isMod && ((key.toLowerCase() === 'z' && e.shiftKey) || key.toLowerCase() === 'y')) {
          e.preventDefault();
          redo();
        }
      });

      // Handle viewport changes (especially iOS address bar show/hide)
      const vv = window.visualViewport;
      if (vv) vv.addEventListener('resize', resizeToViewport);
      window.addEventListener('resize', resizeToViewport);

      // Prevent iOS Safari long-press callout and selection while drawing
      document.addEventListener('gesturestart', (e) => e.preventDefault());
      document.addEventListener('selectstart', (e) => e.preventDefault());
      window.addEventListener('contextmenu', (e) => e.preventDefault());

      // Init
      setActiveSwatchByColor(currentColor);
      setToggleUI();
      resizeToViewport();

      // If launched from Home Screen (iOS), navigator.standalone is true
      // We don't need to do anything special besides sizing & safe-area handling,
      // but this line proves the mode if you ever want to branch styles:
      if (window.navigator.standalone) document.documentElement.classList.add('ios-standalone');
    })();
  </script>
</body>
</html>
